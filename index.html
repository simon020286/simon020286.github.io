<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><script>!function(){try{var d=document.documentElement.classList;d.remove('light','dark');var e=localStorage.getItem("theme");if(e){d.add(e)}else{d.add('dark');}}catch(t){}}();</script><title>T-Dev - Website - T-Dev</title><meta content="Sleep Deprived Father. Senior Web Developer." name="description"/><meta property="og:url" content="https://simon020286.github.io/"/><link rel="canonical" href="https://simon020286.github.io/"/><meta property="og:type" content="website"/><meta property="og:site_name" content="T-Dev - Website"/><meta property="og:description" content="Sleep Deprived Father. Senior Web Developer."/><meta property="og:title" content="T-Dev - Website"/><meta property="og:image" content="https://simon020286.github.io/images/site-preview.png"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@huntarosan"/><meta name="twitter:title" content="T-Dev - Website"/><meta name="twitter:description" content="Sleep Deprived Father. Senior Web Developer."/><meta name="twitter:image" content="https://simon020286.github.io/images/site-preview.png"/><meta name="next-head-count" content="17"/><link rel="preload" href="./_next/static/css/e2908799117bc784.css" as="style"/><link rel="stylesheet" href="./_next/static/css/e2908799117bc784.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="./_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="./_next/static/chunks/webpack-e644fd861cfeb188.js" defer=""></script><script src="./_next/static/chunks/framework-0f8b31729833af61.js" defer=""></script><script src="./_next/static/chunks/main-208998328ec77b24.js" defer=""></script><script src="./_next/static/chunks/pages/_app-aaebc3a3da0532ea.js" defer=""></script><script src="./_next/static/chunks/944-bcdef466c1c513ab.js" defer=""></script><script src="./_next/static/chunks/pages/index-347636c71c8795ce.js" defer=""></script><script src="./_next/static/JCGWcSaViSmzqs3p2T51S/_buildManifest.js" defer=""></script><script src="./_next/static/JCGWcSaViSmzqs3p2T51S/_ssgManifest.js" defer=""></script><script src="./_next/static/JCGWcSaViSmzqs3p2T51S/_middlewareManifest.js" defer=""></script></head><body class="bg-white dark:bg-black text-gray-900 dark:text-white"><div id="__next"><div class="flex flex-col min-h-screen"><header><div class="max-w-5xl px-8 mx-auto"><div class="flex items-center justify-between py-6"><nav><a class="text-gray-900 dark:text-white pr-6 py-4" href="/">Home</a><a class="text-gray-900 dark:text-white px-6 py-4" href="/tags">Tags</a></nav></div></div></header><main class="mb-0 flex-grow"><div class="max-w-5xl px-8 py-4 mx-auto"><h1>Home Page</h1><article class="mt-12"><p class="mb-1 text-sm text-gray-500 dark:text-gray-400">August 06, 2021</p><h1 class="mb-2 text-xl"><a class="text-gray-900 dark:text-white dark:hover:text-blue-400" href="/posts/2021-01-21-visual-studio-code-docker">Visual Studio Code - Docker</a></h1><div><div class="flex space-x-1"><span class="text-gray-500 dark:text-gray-400">visual studio code</span><span class="text-gray-500 dark:text-gray-400">ide</span><span class="text-gray-500 dark:text-gray-400">docker</span></div></div><p class="mb-3">Sviluppare con Visual Studio Code all&#x27;interno di un container Docker</p><p><a href="/posts/2021-01-21-visual-studio-code-docker">Read More</a></p></article><article class="mt-12"><p class="mb-1 text-sm text-gray-500 dark:text-gray-400">April 14, 2021</p><h1 class="mb-2 text-xl"><a class="text-gray-900 dark:text-white dark:hover:text-blue-400" href="/posts/2021-04-14-risolvere-problemi-di-boot-da-ssd-su-raspberry-pi4">Risolvere problemi di boot da SSD su Raspberry Pi4</a></h1><div><div class="flex space-x-1"><span class="text-gray-500 dark:text-gray-400">raspberrypi</span><span class="text-gray-500 dark:text-gray-400">ssd</span><span class="text-gray-500 dark:text-gray-400">bootusb</span></div></div><p class="mb-3">Come risolvere uno dei problemi di boot da USB 3 con adattatore SATA to USB</p><p><a href="/posts/2021-04-14-risolvere-problemi-di-boot-da-ssd-su-raspberry-pi4">Read More</a></p></article><article class="mt-12"><p class="mb-1 text-sm text-gray-500 dark:text-gray-400">December 02, 2020</p><h1 class="mb-2 text-xl"><a class="text-gray-900 dark:text-white dark:hover:text-blue-400" href="/posts/2020-11-12-bitwarden">Bitwarden</a></h1><div><div class="flex space-x-1"><span class="text-gray-500 dark:text-gray-400">self-hosted</span><span class="text-gray-500 dark:text-gray-400">passwordmanage</span><span class="text-gray-500 dark:text-gray-400">bitwarden</span><span class="text-gray-500 dark:text-gray-400">traefik</span></div></div><p class="mb-3">Tutorial per installare Bitwarden tramite docker dietro reverse proxy Traefik</p><p><a href="/posts/2020-11-12-bitwarden">Read More</a></p></article><article class="mt-12"><p class="mb-1 text-sm text-gray-500 dark:text-gray-400">November 12, 2020</p><h1 class="mb-2 text-xl"><a class="text-gray-900 dark:text-white dark:hover:text-blue-400" href="/posts/2020-11-12-traefik-middlewares">Traefik - Middlewares</a></h1><div><div class="flex space-x-1"><span class="text-gray-500 dark:text-gray-400">self-hosted</span><span class="text-gray-500 dark:text-gray-400">traefik</span><span class="text-gray-500 dark:text-gray-400">middlewares</span></div></div><p class="mb-3">Creare i meddlewares base per Traefik</p><p><a href="/posts/2020-11-12-traefik-middlewares">Read More</a></p></article><article class="mt-12"><p class="mb-1 text-sm text-gray-500 dark:text-gray-400">November 10, 2020</p><h1 class="mb-2 text-xl"><a class="text-gray-900 dark:text-white dark:hover:text-blue-400" href="/posts/2020-11-04-traefik-intro">Traefik - Intro</a></h1><div><div class="flex space-x-1"><span class="text-gray-500 dark:text-gray-400">self-hosted</span><span class="text-gray-500 dark:text-gray-400">proxy</span><span class="text-gray-500 dark:text-gray-400">traefik</span></div></div><p class="mb-3">Introduzione a traefik</p><p><a href="/posts/2020-11-04-traefik-intro">Read More</a></p></article></div></main><footer class="py-8"><div class="max-w-5xl px-8 mx-auto">Built by T-Dev</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"slug":"2021-01-21-visual-studio-code-docker","title":"Visual Studio Code - Docker","date":"2021-08-06","description":"Sviluppare con Visual Studio Code all'interno di un container Docker","image":null,"tags":["visual studio code","ide","docker"],"content":"\nCiao a tutti,  \noggi vi mostro il mio ambiente di sviluppo, programmi, linguaggi e tools che utilizzo.  \nPer prima cosa come IDE (Integrated development environment) utilizzo l'ottimo Visual Studio Code di Microsoft.  \nTrovate tutte le informazioni [qui](https://code.visualstudio.com/).  \nIn breve è un software multi-piattaforma, infatti lo trovate per Windows, MacOS e Linux, integra il controllo della versione del codice tramite git, esistono un'infinità di estensioni per facilitare lo sviluppo.\n\n![visual studio code](https://res.cloudinary.com/drg2utgxr/image/upload/v1611249440/posts/vcode/home-screenshot-win-lg_vzx2kh.png 'Visual Studio Code')\n\nGrazie alle tantissime estensioni disponibili è possibile programmare in qualsiasi linguaggio, ma in questo articolo vedremo come sviluppare in golang, sfruttando un container docker in cui installare il compilatore e tutto il necessario in modo da non \"sporcare\" il computer host.\n\nI prerequisti sono pochissimi, aver installato Docker, Visual Studio Code e l'estensione Remote - Containers.\nFatto questo basterà creare la cartella del proprio progetto e al suo interno una cartella chiamata _.devcontainer,_  \nall'interno di essa i seguenti file:\n\n_Dockerfile_\n\n```dockerfile\nFROM golang:1.16\n\nENV DEBIAN_FRONTEND=noninteractive\nRUN apt-get update \\\n    \u0026\u0026 apt-get -y install --no-install-recommends apt-utils 2\u003e\u00261\n\n# Verify git, process tools, lsb-release (common in install instructions for CLIs) installed.\nRUN apt-get -y install git iproute2 procps lsb-release\n\n# Install Go tools.\nRUN go env -w GO111MODULE=off \\\n    \u0026\u0026 apt-get update \\\n    # Install gocode-gomod.\n    \u0026\u0026 go get -x -d github.com/stamblerre/gocode 2\u003e\u00261 \\\n    \u0026\u0026 go build -o gocode-gomod github.com/stamblerre/gocode \\\n    \u0026\u0026 mv gocode-gomod $GOPATH/bin/ \\\n    # Install other tools.\n    \u0026\u0026 go get -u \\\n        golang.org/x/tools/gopls \\\n        github.com/stamblerre/gocode \\\n        github.com/uudashr/gopkgs/cmd/gopkgs \\\n        github.com/ramya-rao-a/go-outline \\\n        github.com/acroca/go-symbols \\\n        golang.org/x/tools/cmd/guru \\\n        golang.org/x/tools/cmd/gorename \\\n        github.com/go-delve/delve/cmd/dlv \\\n        github.com/stamblerre/gocode \\\n        github.com/rogpeppe/godef \\\n        golang.org/x/tools/cmd/goimports 2\u003e\u00261 \\\n    # Clean up.\n    \u0026\u0026 apt-get autoremove -y \\\n    \u0026\u0026 apt-get clean -y \\\n    \u0026\u0026 rm -rf /var/lib/apt/lists/* \\\n    \u0026\u0026 go env -w GO111MODULE=on\n\n# Revert workaround at top layer.\nENV DEBIAN_FRONTEND=dialog\n\n# Expose service ports.\nEXPOSE 8000\n```\n\n_devcontainer.json_\n\n```json\n{\n  \"dockerFile\": \"./Dockerfile\",\n  \"appPort\": [\"8000:8000\"],\n  \"extensions\": [\"golang.go\"]\n}\n```\n\nFatto questo Visual Studio Code ti chiederà se vuoi aprire il workspace all'interno del container, rispondere di si e attendere che docker crei il container. Probabilmente alla fine del processo vi verrà suggerito di installare alcuni tool di golang, accettate e proseguite.  \nDopo qualche secondo sarà possibile iniziare a sviluppare normalmente.  \nLa cosa bella di questo processo è che i file che scriverete saranno fisicamente sul sistema host, quindi navigabili e gestibile dal file manager, ma tutte le librerie e eseguibili di go saranno all'interno del container.  \nQuesto rende più semplice la gestione delle varie versione di golang e delle dipendenze dei propri progetti.  \nOvviamente tutto questo è possibile utilizzarlo per molti linguaggi di programmazione ad esempio Python, Flutter, C# e molti altri.\n\nSpero di avervi aiutato e fatto scoprire qualcosa di nuovo.  \nCome al solito contattatemi pure nei commenti se avete bisogno di aiuto.\n"},{"slug":"2021-04-14-risolvere-problemi-di-boot-da-ssd-su-raspberry-pi4","title":"Risolvere problemi di boot da SSD su Raspberry Pi4","date":"2021-04-14","description":"Come risolvere uno dei problemi di boot da USB 3 con adattatore SATA to USB","image":null,"tags":["raspberrypi","ssd","bootusb"],"content":"\nBuongiorno a tutti,  \nrecentemente ho comprato un Raspberry Pi 4 8GB di Ram da utilizzare come pc per la famiglia, collegato alla tv, in modo da poter navigare comodamente su internet, editare qualche documento, stampare ecc. ecc. insomma un utilizzo saltuario e che non richiede requisiti hardware eccessivi.\n\nPer migliorare un po' l'esperienza d'uso ho deciso di utilizzare come archivio primario un SSD Kingston da 240GB comprato per poche decine di euro su Amazon. Il boot e l'esperienza generale sarebbe stata molto più veloce e fluida.  \nOvviamente, come capita sempre a me, non potevano che esserci dei problemi, infatti seguendo tutte le guide disponibili online non c'era verso di avviare qualsiasi sistema dalla porta USB3, ma solo dalla USB2, perdendo così parte del vantaggio dell'utilizzo dell'SSD.  \nIndagando un po' ho scoperto che la causa è il controllore utilizzato dall'adattatore, nel mio caso un JMicron, ma capita la causa non riuscivo a trovare nessuna soluzione, quando oramai mi stavo per arrendere mi sono imbattuto in questo articolo.  \n\u003chttps://www.raspberrypi.org/forums/viewtopic.php?t=245931\u003e\n\nIn pratica per far funzionare correttamente l'SSD è sufficiente aprire un terminale e dare `lsusb` dopo aver collegato l'SSD, se non avete modo di utilizzare il raspberry avviandolo da scheda di memoria, basta collegare l'SSD a una delle porte USB2.\n\n![lsusb](https://res.cloudinary.com/drg2utgxr/image/upload/v1618490056/posts/risolvere-problemi-di-boot-da-ssd-su-raspberry-pi4%20/2021-04-14_17-28_hcttky.png 'Terminale')\n\nOra basta aggiungere all'inizio del file `/boot/cmdline.txt`, ovviamente quello che risiede sull'SSD, la seguente stringa `usb-storage.quirks=aaaa:bbbb:u`, dove aaaa:bbbb è l'id trovato in precedenza.\n\nRiavviate il raspberry con l'SSD collegato a una posta USB3 e godetevi il sistema alla massima velocità.\n"},{"slug":"2020-11-12-bitwarden","title":"Bitwarden","date":"2020-12-02","description":"Tutorial per installare Bitwarden tramite docker dietro reverse proxy Traefik","image":null,"tags":["self-hosted","passwordmanage","bitwarden","traefik"],"content":"\nBuongiorno a tutti, eccoci con un nuovo articolo.  \nOggi vedremo come utilizzare un password manager il cui server gira interamente sul tuo host personale.  \nIniziamo col dire che come server non utilizzeremo Bitwarden ufficiale, ma una versione compatibile Bitwarden_Rs,  \nscritto in Rust che implementa quasi tutte le API ufficiali. E' molto più leggero, completamente gratuito, e in più utilizza l'app e le estensioni per browser ufficiali.  \nCome detto nell'articolo dedicato a Traefik ([link](/posts/2020-11-04-traefik-intro)) è possibile impostare l'utilizzo del reverse proxy tramite labels, come potete vedere nel `docker-compose.yml` seguente.\n\n```yaml\nversion: '3'\n\nnetworks:\n  traefik_network:\n    external:\n      name: traefik_trproxy\nservices:\n  bitwarden:\n    image: 'bitwardenrs/server'\n    container_name: bitwarden\n    environment:\n      DOMAIN: 'https://\u003cdominio\u003e'\n      LOG_FILE: /shared/logs/bitwarden/bitwarden.log\n      LOG_LEVEL: warn\n      ROCKET_LOG: critical\n      WEBSOCKET_ENABLED: 'true'\n      SIGNUPS_ALLOWED: 'false'\n    labels:\n      traefik.enable: true\n      traefik.docker.network: traefik_trproxy\n      traefik.http.middlewares.bitwarden-security.headers.browserXssFilter: true\n      traefik.http.middlewares.bitwarden-security.headers.contentTypeNosniff: true\n      traefik.http.middlewares.bitwarden-security.headers.customResponseHeaders.X-Robots-Tag: noindex,nofollow,nosnippet,noarchive,notranslate,noimageindex\n      traefik.http.middlewares.bitwarden-security.headers.forceSTSHeader: true\n      traefik.http.middlewares.bitwarden-security.headers.frameDeny: true\n      traefik.http.middlewares.bitwarden-security.headers.sslRedirect: true\n      traefik.http.middlewares.bitwarden-security.headers.sslHost: \u003cdominio\u003e\n      traefik.http.middlewares.bitwarden-security.headers.stsIncludeSubdomains: true\n      traefik.http.middlewares.bitwarden-security.headers.stsPreload: true\n      traefik.http.middlewares.bitwarden-security.headers.stsSeconds: 315360000\n      traefik.http.services.bitwarden.loadbalancer.server.scheme: http\n      traefik.http.services.bitwarden.loadbalancer.server.port: 80\n      traefik.http.services.bitwarden-ws.loadbalancer.server.port: 3012\n      traefik.http.routers.bitwarden-http.service: bitwarden\n      traefik.http.routers.bitwarden-http.rule: Host(`\u003cdominio\u003e`)\n      traefik.http.routers.bitwarden-http.entrypoints: http\n      traefik.http.routers.bitwarden-http.middlewares: bitwarden-security, gzip-compress@file, redirect-to-https@file\n      traefik.http.routers.bitwarden.service: bitwarden\n      traefik.http.routers.bitwarden.rule: Host(`\u003cdominio\u003e`)\n      traefik.http.routers.bitwarden.entrypoints: https\n      traefik.http.routers.bitwarden.middlewares: bitwarden-security, gzip-compress@file\n      traefik.http.routers.bitwarden.tls: true\n      traefik.http.routers.bitwarden.tls.certresolver: le\n      traefik.http.routers.bitwarden-ws.service: bitwarden-ws\n      traefik.http.routers.bitwarden-ws.rule: Host(`\u003cdominio\u003e`) \u0026\u0026 Path(`/notifications/hub`)\n      traefik.http.routers.bitwarden-ws.entrypoints: https\n      traefik.http.routers.bitwarden-ws.middlewares: bitwarden-security\n      traefik.http.routers.bitwarden-ws.tls: true\n      traefik.http.routers.bitwarden-ws.tls.certresolver: le\n    networks:\n      - traefik_network\n    restart: unless-stopped\n    volumes:\n      - \u003cdir\u003e/data:/data\n      - \u003cshared dir\u003e:/shared\n```\n\nE' molto importante rispettare alcune regole.\n\n1. il nome della connessione `traefik_network` deve essere lo stesso definito per traefik\n2. `LOG_FILE: /shared/logs/bitwarden/bitwarden.log` il path `/shared` deve essere lo stesso mappato nel volume\n3. `SIGNUPS_ALLOWED: \"false\"` al primo avvio bisogna impostarlo a `true`, altrimenti non sarà possibile registrare nessun utente, io l'ho messo a `false` dopo aver creato il mio utente e quello di mia moglie, in modo che nessuno sconosciuto si possa registrare. Siete liberi di lasciarlo a `true`.\n4. sostituire `\u003cdominio\u003e` con il vostro dominio\n\nFatto questo è possibile lanciare il container semplicemente con il comando `docker-compose up -d`.  \nAvviato il container sarà possibile procedere alla registrazione del primo utente andato all'url specificato in `\u003cdominio\u003e`.\n\nBuon divertimento con il vostro nuovo password manager.\n"},{"slug":"2020-11-12-traefik-middlewares","title":"Traefik - Middlewares","date":"2020-11-12","description":"Creare i meddlewares base per Traefik","image":null,"tags":["self-hosted","traefik","middlewares"],"content":"\nBuongiorno a tutti,  \noggi vedremo come creare i primi e più semplici middlewares per Traefik.  \nCosa è un middleware?  \nSemplificando molto è qualcosa che si frappone tra la chiamata e il servizio finale o viceversa.\n\n![middlwares](https://doc.traefik.io/traefik/assets/img/middleware/overview.png 'Esempio middlewares Traefik')\n\nNella mia configurazione ho creato tre middlewares che trovo molto utili. Per crearli basta creare un file all'interno della cartella dynamic vista nel primo articolo dedicato a Traefik ([lo trovate qui](/posts/2020-11-04-traefik-intro/)).  \nE' anche possibile crearli tramite label dei container, utile se è specifico per un determinato servizio.\n\n1. Redirect to https, abbastanza semplice da capire, effettua il redirect delle chiamate verso lo schema specificato. Nel mio caso tutte verso https.\n\n   ```yaml\n   ---\n   http:\n     middlewares:\n       redirect-to-https:\n         redirectScheme:\n           scheme: https\n   ```\n\n2. Basic auth, utile per redendere un po' più sicuro un endpoint aggiungendo un'autenticazione.  \n   E' possibile specificare l'elenco di coppie username: password, la password deve essere criptata tramite MD5, SHA1, o BCrypt, per fare questo è possibile utilizzare su sistemi Linux `htpasswd`. E' anche possibile specificare il path di un file contenente gli utenti, sempre nello stesso formato, tramite l'attributo `usersFile `al posto di `users`.\n\n   ```yaml\n   ---\n   http:\n     middlewares:\n       basic-auth:\n         basicAuth:\n           users:\n             - '\u003cusername\u003e:\u003cpassword\u003e'\n   ```\n\n3. Compressione della risposta, credo sia uno dei più importanti per limitare il consumo di banda. Comprime le risposte limitando appunto i dati scambiati.\n\n   ```yaml\n   ---\n   http:\n     middlewares:\n       gzip-compress:\n         compress: {}\n   ```\n\nPer utilizzare un middleware basta specificarlo nella configurazione della route.\n\n```yaml\n# Se utilizzate un file come impostazione.\nhttp:\n  routers:\n    nome-route:\n      middlewares:\n        - gzip-compress\n        - redirect-to-https\n\n# Se utilizzate le labels di un container come impostazione.\ntraefik.http.routers.nome-route.middlewares: gzip-compress@file, redirect-to-https@file\n```\n\nSpero di esservi stato utile e rimango sempre a disposizione per aiutarvi.\n"},{"slug":"2020-11-04-traefik-intro","title":"Traefik - Intro","date":"2020-11-10","description":"Introduzione a traefik","image":null,"tags":["self-hosted","proxy","traefik"],"content":"\nBuongiorno,  \noggi parleremo da [Traefik](https://doc.traefik.io/traefik/), un HTTP reverse proxy e load balancer.\n\n![architettura](https://doc.traefik.io/traefik/v1.7/img/architecture.png)\n\nIo lo sto utilizzando per rendere accessibili dall'esterno dei servizi hostati sul mio nas, come ad esempio Home Assistant e l'ottimo password manager Bitwarden (di cui probabilmente parlerò su questo blog).  \nSi integra perfettamente con docker, è infatti in grado di leggere automaticamente le impostazioni da un container tramite label.  \nVediamo ora come installarlo proprio tramite docker, più precisamente utilizzando docker-compose per semplificare le cose.\n\nPer prima cosa scriviamo il file di configurazione. Ci sono vari modi per configurare Traefik, via argomenti da linea di comando o via file traefik.yml, che è la strada che ho scelto io perché mi sembra più chiara. Ho commentato direttamente nel file le parti \"meno\" importanti.\n\n```yaml\n---\nglobal:\n  # Verifica la presenza di nuove versioni.\n  checkNewVersion: true\n\nentryPoints:\n  http:\n    address: :80\n    forwardedHeaders:\n      insecure: true\n    proxyProtocol:\n      insecure: true\n  https:\n    address: :443\n    forwardedHeaders:\n      insecure: true\n    proxyProtocol:\n      insecure: true\n\nproviders:\n  docker:\n    watch: true\n    exposedByDefault: false\n    endpoint: 'unix:///var/run/docker.sock'\n  file:\n    directory: '/etc/traefik/dynamic/'\n    watch: true\n\napi:\n  # Visualizza l'interfaccia web della dashboard e permetti connessioni non sicure.\n  dashboard: true\n  insecure: true\n\n# Salva il log nel percorso specificato, con livello DEBUG.\n# Ovviamente una volta impostato e verificato il corretto funzionamento si può abbassare il livello.\nlog:\n  filePath: '/shared/logs/traefik/traefik.log'\n  level: DEBUG\n\n# Salva il log delle chiamate nel percorso specificato.\n# E' possibile specificare dei filtri, nel mio caso solo le chiamate con condici di errore.\naccessLog:\n  filePath: '/shared/logs/traefik/access.log'\n  filters:\n    statusCodes: ['400-599']\n\n# Let's encrypt configuration\ncertificatesResolvers:\n  le:\n    acme:\n      email: \u003cemail\u003e\n      storage: /etc/traefik/acme/acme.json\n      tlschallenge: true\n```\n\nPer prima cosa vengono definiti gli entry points sono i punti di ingresso che può accettare il nostro proxy.  \nIo mi attendo delle connessioni dalla porta 80 e 443, è possibile aggiungere molte altre opzioni, ma per questo approfondimento vi rimando alla guida ufficiale.  \nI providers sono le risorse da cui è possibile accettare le configurazioni dinamiche, ossia i servizi, le routers e i middlewares.\n\n- docker: permette di creare delle configurazioni tramite le labels di un container.\n\n  - watch: true indica a traefik di rimanere in ascolto di modifiche sui containers, così non sarà necessario riavviare il server ad ogni modifica.\n  - exposedByDefault: false, bisogna specificare in un container se esporlo a traefik, altrimenti per ogni nuovo container in esecuzione verrà creato un servizio.\n  - endpoint: \"unix:///var/run/docker.sock\" il percorso del sock di docker per permettere la comunicazione con esso. Nel nostro caso sarà l'istanza di docker installata sul sistema host, come vedremo in seguito.\n\n- file: permette di creare le configurazioni tramite file o files yaml o toml.\n\n  - directory: \"/etc/traefik/dynamic/\" ho optato per indicare una cartella in modo da poter suddividere in modo più ordinato le impostazioni. E' possibili anche indicare un singolo file tramite l'impostazione `filename`.\n  - watch: true come sopra.\n\nL'altra parte molto importante del file è `certificatesResolvers`, cioè il modo in cui risolvere i certificati SSL.  \nNel mio caso utilizzo Let's Encrypt, un servizio gratuito che permette la generazione di certificati. Traefik integra già tutto il funzionamento basta utilizzare come provider `acme`. Le altre impostazioni sono molto semplici, una email valida per ricevere avvisi di scadenza dei certificati e il percorso dove salvare gli stessi.\n\nDefinita la configurazione base possiamo passare alla creazione del file docker-compose.yml per la creazione del container.\n\n```yaml\nversion: '3'\n\nnetworks:\n  trproxy:\n    driver: bridge\n\nservices:\n  traefik:\n    container_name: traefik\n    image: traefik:latest\n    restart: unless-stopped\n    networks:\n      - trproxy\n    environment:\n      - TZ:\"Europe/Rome\"\n    ports:\n      - 8080:8080\n      - 80:80\n      - 443:443\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      - \u003cdir\u003e/traefik.yml:/etc/traefik/traefik.yml:ro\n      - \u003cdir\u003e/dynamic:/etc/traefik/dynamic/:ro\n      - \u003cdir\u003e/acme/acme.json:/etc/traefik/acme/acme.json\n      - \u003cdir\u003e/shared:/shared\n```\n\nPer prima cosa viene definita la connessione, verrà utilizzata dai containers che vogliono collegarsi a traeik.  \nLe tre porte esposte sono:\n\n- 8080 dedicata alla dashboard\n- 80 per le connessioni non sicure\n- 443 per le connessioni sicure\n\nI volumi invece:\n\n- /var/run/docker.sock percorso sock docker installato sull'host\n\nScritto il file `docker-compose.yml` lanciamo il servizio con `docker-compose up -d`. In base alla connessione e potenza della macchina host ci può volere anche qualche minuto. Quando sarà tutto finito potrete raggiungere la dashboard da browser tramite http:\\\\\\\\\u003c ip della macchina su cui lo avete installato\u003e:8080.  \nSaranno già presenti un paio di servizi, tranquilli sono quelli interni che vengono creati dal proxy.\n\nCon questo la piccola guida è finita.  \nSpero di esservi stato utile.\n"}]},"__N_SSG":true},"page":"/","query":{},"buildId":"JCGWcSaViSmzqs3p2T51S","assetPrefix":".","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>